# 执行上下文&作用域&闭包
- 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限
- JS采用了词法作用域的形式，也就是静态作用域
## 词法作用域
- 在词法作用域中，函数的作用域在函数定义的时候就决定了
var a = 2;
function foo() {
    console.log(a);
}
function bar() {
    var a = 3
    foo();
}
bar(); // 2
- 根据词法作用域，我们来分析一下过程
  - 首先是执行bar函数，里面定义了一个局部变量var a = 3
  - 然后执行foo函数，先从foo函数内部寻找是否有局部变量a，没有的话，就根据书写的位置（定义函数时候的位置，在定义时会形成一个不完整的作用域链，这个我们后面会讲到）去查找上一个作用域，也就是var a = 2这一段
  - 此时，找到了变量a打印出来结果是2
## 执行上下文
- 当我们要执行一个函数的时候，要进行一些准备工作（确定一些参数，环境什么的），这些准备工作就是执行上下文
- JS引擎通过执行上下文栈来管理这些上下文
### 上下文栈的工作流程
- 首先，是全局的代码，所以最开始的时候，会将全局上下文压入栈，只有当整个程序都结束的时候，这个全局上下文才会被弹出
- 接着，要执行一个函数，就把他对应的上下文压入栈，等函数返回的时候，再弹栈
- 举个栗子：
```JavaScript
function func3() {
    console.log('func3');
}
function func2() {
    func3();
    console.log('func2');
}
function func() {
    func2();
    console.log('func');
}
func();
/**
* func3
* func2
* func
*/
```
- 上述代码中，首先先将全局上下文压入栈，然后将func()函数压入栈
- 然后发现func()函数里面调用了func2()函数，所以，将func2()压入栈
- 同理，将func3()压入栈，然后打印'func3'，返回，将func3()弹出栈
- 继续执行func2()，打印'func3'，返回，弹栈
- 继续执行func()，打印'func'
- 此时，执行栈里面，仍然存在着全局上下文
### 上下文的三个重要属性
- 执行上下文一般有许多东西，但主要有三个，分别是：变量对象，作用域链，this指针
#### 变量对象(Variable Object, VO)
- 变量对象是执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明
- 主要有全局上下文变量和函数上下文变量
  - 全局上下文可以理解为全局对象
  - 函数上下文分两阶段，第一阶段是将“声明变量”，第二阶段是执行“赋值”代码，将第一阶段声明的内容赋值
##### 全局上下文变量对像
- 用全局对象来表示全局上下文变量对象
  - 可以通过this引用，在浏览器端中，全局对象就是Window对象，同时，有一个window属性指向自身this.window == this; // ture
- 全局对象里面有许多方法，如Math.random()等
- 是全局变量的宿主，也就是说，定义在全局的变量，实际上是全局对象的一个属性
  - W3School中的解释: 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。 
var a = 1;
console.log(this.a); // 1
##### 函数上下文变量对象
- 在函数上下文中，使用活动对象(Activation Object, AO)这个新名词来表示函数上下文变量对象
- 为什么叫活动对象？
  - 只有当进入一个执行上下文的时候，这个执行上下文的变量对象才会被被激活，而只有被激活的变量对象，他的各种属性我们才能访问
- 通过函数的arguments属性来初始化
###### 执行过程
- 主要有两步
  - 进入执行上下文
  - 代码执行
- 进入执行上下文
  - 此时还未执行代码
  - 变量对象主要有，函数的形参，函数声明，变量声明（值全都是undefined）
  - 例子：
```JavaScript
function foo(a) {
    var b = 1;
    function c() {};
    var d = function() {};
    b = 3;
}
foo(1);

/**
* 此时，活动对象是这样的：

AO = {
    arguments: {
        0: 1,length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
*/
```
- 代码执行阶段
  - 会顺序执行代码，根据代码，修改变量的值
```JavaScript
/**
* 此时，活动对象是这样的：
AO = {
    arguments: {
        0: 1,length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
*/
```
##### 练习（不应该在此处，应该是变量提升的问题）
```JavaScript
- 第一题：
function foo() {
    console.log(a);
    a = 1;
}
foo(); // Uncaught ReferenceError: a is not defined

function bar() {
    b = 1;
    console.log(b);
}
bar(); // 1
```
  - 变量a因为没有用关键字声明，所以是全局变量
  - 在执行foo()函数的时候，首先打印a，所以会沿着作用域链去寻找，发现没有a，所以会报错
  - 在执行bar()函数的时候，已经声明了变量b，所以，此时在全局对象中找到了b,打印1
- 第二题
```JavaScript
console.log(a); // 会打印出函数a，而不是变量a

function a() {
    console.log('a');
}

var a = 1;
```
  - 注意： 在进入执行上下文的时候，会优先处理函数声明，再处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
  - 这个问题涉及变量提升的内容，这一块的内容在另外一篇文章中
#### 作用域链(Scope Chain)
- 这里可以插一段词法作用域的介绍
- 当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链
- 根据词法作用域，函数的作用域在函数定义的时候就已经确定了
  - 函数内部有一个[[scope]]的属性，保存着所有的父变量对象，可以说，这个属性就是父变量对象的作用域链，但是，此时（函数定义阶段），这个属性不能算是这个函数的完整作用域链
  - 在函数执行阶段，会激活活动对象，然后将活动对象添加到作用域链的最前端，此时，关于这个函数的完整作用域链才创建完毕
#### 总结一下
  - 代码部分：
```JavaScript
var scope = "global";
function a() {
    var scope2 = "local";
    return scope2;
}

a();
```
  - 首先，是a()函数被创建，保存当前的词法作用域到内部属性[[scope]]
  - 接着是是执行a()函数，在执行之前，要先创建函数执行上下文，压入执行上下文栈
  - 创建的第一步是将函数的[[scope]]属性复制，创建作用域链，然后初始化活动对象（第一阶段，加入形参，函数声明，变量声明），接下来将活动对象添加到作用域链的最前端，形成完整的作用域链，压入上下文执行栈
  - 正式开始执行函数，随着函数的执行，修改前面声明变量的属性值
  - 函数找到scope2，返回函数，弹出执行栈，此时上下文栈剩下全局上下文
  - 至于创建上下文的时候，为什么是复制[[scope]]属性，而不是直接修改（指针指向就好），是因为，函数在创建的时候，我们不能确定最终的作用域链，同时，函数还会回被调用多次，所以要采取复制的方法，而不是直接修改
#### this
- this总指向函数执行时的上下文变量
- 后面再补充

## 执行上下文与闭包
### 楔子
- 这里我们从一个例子讲起
let globalScope = "global";
function checkScope() {
    let localScope = "local";
    function foo() {
        console.log(localScope);
    }
    return foo;
}
let bar = checkScope();
bar(); // "local"
- 这里，我们尝试从执行上下文的角度来解释上述代码的运行过程
  - 首先，创建全局上下文，同时，将其压入上下文栈，初始化全局上下文
  - 定义checkScope()函数，保存当前作用域链到函数的内部属性[[scope]]
  - 执行checkScope()函数，初始化checkScope()函数的活动对象
  - 接着定义foo()函数，将当前的作用域链保存到foo()函数的内部属性[[scope]]，
  - 与此同时，将checkScope()函数的活动对象添加到checkScope()函数的作用域链的顶端，并将其的函数上下文压入上下文栈
  - 开始真正执行checkScope()函数，给其活动对象的属性赋值
  - 执行完毕，返回foo()函数，同时，弹出上下文栈
  - 接着，执行bar()函数，初始化foo()函数的执行上下文（声明变量那些...）, 将活动对象添加到foo()函数的作用域顶端，最后压入上下文栈
  - 开始执行bar()函数，开始寻找global变量，沿着作用域链寻找global变量，在第二级作用域那里找到，打印"global"，函数返回，弹出上下文栈
  - 此时，上下文栈中，只有一个全局上下文栈
- 现在，我们来思考一个问题，在checkScope()函数执行完后，弹出上下文栈，按照道理，里面的localScpoe变量应该已经被销毁，但是，为什么在我们执行bar()函数的时候，还是会找到这个变量呢？
  - 这里，我们的foo()函数，维护这一条作用域链，正是因为这一条作用域链，foo()函数可以读取到checkscope()函数的活动对象中的属性，即使checkScope()函数上下文被销毁，foo()函数还是可以沿着这一条链找到，这代表着global变量因为这条作用域链，仍然存在于内存中
  - JS正是通过这个特性，实现了闭包
### 闭包的定义
- 现在我们回过头来，看看闭包的定义
  - 红宝书：闭包是指那些引用了另外一个函数作用域中变量的函数
  - MDN：闭包让你可以在一个内层函数中访问到其外层函数的作用域
  - 现在来看，闭包确实如此，引用着外层函数的作用域
### 闭包经典问题
- 栗子1：
```JavaScript
var data = [];

for (var i = 0; i < 3; i++) {
    data[i] = function() {
        console.log(i);
    }
}

data[0](); // 3
data[1](); // 3
data[2](); // 3
```
  - 在函数执行的时候，会顺着作用域链去寻找i，函数活动对象没有i，而此时，全局上下文中的i是3，所以，都会打印3
```JavaScript
// 上下文示意图
// 全局
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
// data[0]函数的作用域链,其余的同理
data[0]Context = {
    Scope: [AO, globalContext.VO]
}
// 此时，活动对象中没有i，所以会沿着作用域链到全局去找，找到i=3
- 怎么使得每次打印对应的i？
var data = [];

for (var i = 0; i < 3; i++) {
    data[i] = (function() {
        return function () {
            console.log(i);
        }
    })();
}

data[0](); // 0
data[1](); // 1
data[2](); // 2
```
  - 这里使用闭包，此时的全局上下文仍然后i = 3，但是，在匿名函数的活动对象中，保存着一个i = 0，所以，在执行data[0]的时候，会沿着作用域链，首先找到data[0]函数上下文中的i，所以会打印0，同理，data[1]会打印1，data[2]会答应2
// 上下文示意图
// 全局上下文
```JavaScript
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}


// 匿名函的上下文（活动对象）
匿名函数Context = {
    AO: {
        arguments: {
            0: 0,
            length: 1
        },
        i: 0
    }
}

// data[0]函数的作用链
data[0]Context = {
    Scope: [AO, 匿名函数Context.AO globalContext.VO]
}

// 所以，沿着作用域找，首先在匿名函数的活动对象查找，找到i=0
```