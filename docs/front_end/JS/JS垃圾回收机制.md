# 垃圾回收机制

- 原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的 => 解决了内存分配问题

## 回收方式

### 手动回收

- 如： C++
- 何时分配内存、何时销毁内存都是由代码控制的，这就容易造成内存泄漏等安全问题，但接近底层，灵活

### 自动回收

- 如Java，Python，JS
- 由垃圾回收器来回收，并不需要代码手动释放，减小心智负担

## 调用栈中的数据如何回收

- 以下面这段代码为例
  ```javascript
  function foo () {
      let a = 1
      let b = { name: 'glows777' }
      function showName () {
          let c = 2
          let d = { name: '香橙派来的' }
      }
      showName()
  }
  ```

- 执行到`showName()`函数的时候，会创建`showName()`函数的上下文，同时，还有一个**记录当前执行状态的指针（ESP）**指向调用栈中 `showName()` 函数的执行上下文，表示当前正在执行 showName 函数

- 接着，当 `showName()` 函数执行完成之后，函数执行流程就进入了 `foo()` 函数，那这时就需要销毁 `showName()` 函数的执行上下文了。ESP 这时候就帮上忙了，JS引擎会将 ESP 下移到 `foo()` 函数的执行上下文

- 此时，上面 `showName()` 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。所以当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文

- 总的来说，JS引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文，本质上是覆盖

## 堆中的数据如何回收

