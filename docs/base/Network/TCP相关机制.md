# 重传机制

## 超时重传

- 在发送数据时，设置一个定时器，在超过指定时间没有收到对方的ACK确认报文后，会重发这个数据

- 以下由两种情况会触发超时重传
  - 数据包丢失
  - 确认应答丢失

### 如何设置合理的超时重传时间（Retransmission Timeout -> RTO）

- 如果设置太大，重发就慢，效率差
- 如果设置太小，则会多发一次，浪费资源
- 所以，RTO应该比RTT略微大一点
  - 这里要考虑网络的波动情况
  - 所以会进行一些采样，加权等操作，最后得出一个平滑的RTO，同时，这个RTT也是会不断变化
- **每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送**

## 快速重传

- 对比超时重传，是以数据作为驱动，而不是时间
- 工作方式是当收到三个相同的 ACK 确认报文时，会在定时器过期之前，重传丢失的报文段
- 快速重传解决了超时重传的RTO设置问题，但是仍然存在一个问题 -> **重传的时候，是重传一个报文，还是重传所有报文的问题**
  - 例子： 假设发送发A发送了6个数据。分别是Seq1-Seq6，但是Seq2， Seq3丢失了
  - 那么这时，接收方B接收到Seq4， 5，6后，会连发三个ACK2到发送方A
  - 此时，发送方A并不知道，是要重传Seq2就好了，还是需要重传Seq2后的所有报文
  - 如果只传Seq2，那么效率很低，后面还需要再一次发送三个ACK3，来让发送发A重传Seq3
  - 而如果重传Seq2后的所有报文，虽然可以一次性重传丢失的Seq2，3，但是，Seq4-6已经成功接收过了，此时就会浪费资源
- 这个问题由SACK机制来解决

## SACK（Selective Acknowledgment，选择性确认）

- 这种方式是在TCP的头部字段中，加一个SACK的字段，这样就**可以将已收到的数据的信息发送给「发送方」**，发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**

## D-SACK(Duplicate SACK)

- **使用了 SACK 来告诉「发送方」有哪些数据被重复接收了**
- ...

# 滑动窗口

- TCP每发送一次数据，就需要一次应带，随后才能继续发送，这样的效率过低，而且有个明显的缺点： 数据包的**往返时间越长，通信的效率就越低**
- 为了解决上述问题，TCP引入了窗口的概念，这样的话，即使在往返时间较长的情况下，它也不会降低网络通信的效率
- 窗口的大小就是指**无需等待确认应答，而可以继续发送数据的最大值**
- 同时，采用的累计确认（累计应答）的模式
  - 这就意味着，如果一个窗口内发送了多个报文（100-199，200-299，300-399），接收方回复了3个确认ACK（ACK200， ACK300，ACK400），此时，因为网络原因，ACK300没有收到，但是ACK400收到了
  - 那么，发送方就会认为ACK400前的数据，都被正确接收了
- TCP头的一个字段叫Windows，表示的窗口大小
  - **这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来**
  - 所以，一般来说，窗口大小是由接收方窗口大小决定的
  - 发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据

# 流量控制

- 如果一直无脑的发数据给对方，但接收方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费，所以TCP引入了流量控制机制
- **所谓的流量控制，其实就是TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量**
- 主要是通过窗口来实现
- 在发送过程中，会根据接收方返回的确认报文信息，不断调整发送窗口大小（根据缓冲区等因素来调整）

## 窗口关闭

- **如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭**
- 会存在风险，因为接收方通知发送方窗口关闭时，是通过ACK报文来通知的，而在重新启动时，而是通过发送一个窗口不为0的ACK报文来通知发送方可以继续发送
- 此时，如果接收方发送的窗口部位0的ACK报文在网络中丢失了，那么这会导致发送方一直等待着接收方这个报文，而发送方也会一直等待发送方的数据
- 这就造成了**死锁**

### 如何解决死锁

- TCP 为每个连接设有一个持续定时器，**只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器**
- 如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小
  - 如果接收窗口不为0，那么发送方收到返回的ACK报文后，会重新开始发送数据，死锁的情况就会被打破
  - 如果仍然为0，那么收到ACK报文回复的发送方会重新启动持续计时器
- 窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 `RST` 报文来中断连接

## 糊涂窗口综合征

- 如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小
- 到最后，**如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**
- 糊涂窗口会造成资源的浪费
- 打个比方： 假设有一辆大巴可以载30人，但是每次来了1-2个人后，就直接发车，而不是等人多才一起发，那这样就很浪费资源
- 可以去仔细看看这个，[参考链接](https://www.xiaolincoding.com/network/3_tcp/tcp_feature.html#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87)

### 如何解决糊涂窗口

- 本质上，出现糊涂窗口的原因就是接收方可以通告给发送方一个较小的窗口，而且发送方又能发送小数据
- 所以，要从这两方面入手
- 接收方
  - 当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 `0`，也就阻止了发送方再发数据过来。
  - 等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来
- 发送方（ Nagle 算法，二者满足一个即可）
  - 要等到窗口大小 >= `MSS` 并且 数据大小 >= `MSS`
  - 收到之前发送数据的 `ack` 回包

- 在这之中，最重要的是，接收方要尽量实现不通告小窗口给发送方

# 其他

## RTT(Round-Trip Time 往返时延)

- 指的是**数据发送时刻到接收到确认的时刻的差值**，也就是包的往返时间

