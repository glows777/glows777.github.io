# 重传机制

## 超时重传

- 在发送数据时，设置一个定时器，在超过指定时间没有收到对方的ACK确认报文后，会重发这个数据

- 以下由两种情况会触发超时重传
  - 数据包丢失
  - 确认应答丢失

### 如何设置合理的超时重传时间（Retransmission Timeout -> RTO）

- 如果设置太大，重发就慢，效率差
- 如果设置太小，则会多发一次，浪费资源
- 所以，RTO应该比RTT略微大一点
  - 这里要考虑网络的波动情况
  - 所以会进行一些采样，加权等操作，最后得出一个平滑的RTO，同时，这个RTT也是会不断变化
- **每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送**

## 快速重传

- 对比超时重传，是以数据作为驱动，而不是时间
- 工作方式是当收到三个相同的 ACK 确认报文时，会在定时器过期之前，重传丢失的报文段
- 快速重传解决了超时重传的RTO设置问题，但是仍然存在一个问题 -> **重传的时候，是重传一个报文，还是重传所有报文的问题**
  - 例子： 假设发送发A发送了6个数据。分别是Seq1-Seq6，但是Seq2， Seq3丢失了
  - 那么这时，接收方B接收到Seq4， 5，6后，会连发三个ACK2到发送方A
  - 此时，发送方A并不知道，是要重传Seq2就好了，还是需要重传Seq2后的所有报文
  - 如果只传Seq2，那么效率很低，后面还需要再一次发送三个ACK3，来让发送发A重传Seq3
  - 而如果重传Seq2后的所有报文，虽然可以一次性重传丢失的Seq2，3，但是，Seq4-6已经成功接收过了，此时就会浪费资源
- 这个问题由SACK机制来解决

## SACK（Selective Acknowledgment，选择性确认）

- 这种方式是在TCP的头部字段中，加一个SACK的字段，这样就**可以将已收到的数据的信息发送给「发送方」**，发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**

## D-SACK(Duplicate SACK)

- **使用了 SACK 来告诉「发送方」有哪些数据被重复接收了**
- ...

# 滑动窗口

- TCP每发送一次数据，就需要一次应带，随后才能继续发送，这样的效率过低，而且有个明显的缺点： 数据包的**往返时间越长，通信的效率就越低**
- 为了解决上述问题，TCP引入了窗口的概念，这样的话，即使在往返时间较长的情况下，它也不会降低网络通信的效率
- 窗口的大小就是指**无需等待确认应答，而可以继续发送数据的最大值**
- 同时，采用的累计确认（累计应答）的模式
  - 这就意味着，如果一个窗口内发送了多个报文（100-199，200-299，300-399），接收方回复了3个确认ACK（ACK200， ACK300，ACK400），此时，因为网络原因，ACK300没有收到，但是ACK400收到了
  - 那么，发送方就会认为ACK400前的数据，都被正确接收了
- TCP头的一个字段叫Windows，表示的窗口大小
  - **这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来**
  - 所以，一般来说，窗口大小是由接收方窗口大小决定的
  - 发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据

# 流量控制

- 如果一直无脑的发数据给对方，但接收方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费，所以TCP引入了流量控制机制
- **所谓的流量控制，其实就是TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量**
- 主要是通过窗口来实现
- 在发送过程中，会根据接收方返回的确认报文信息，不断调整发送窗口大小（根据缓冲区等因素来调整）

## 窗口关闭

- **如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭**
- 会存在风险，因为接收方通知发送方窗口关闭时，是通过ACK报文来通知的，而在重新启动时，而是通过发送一个窗口不为0的ACK报文来通知发送方可以继续发送
- 此时，如果接收方发送的窗口部位0的ACK报文在网络中丢失了，那么这会导致发送方一直等待着接收方这个报文，而发送方也会一直等待发送方的数据
- 这就造成了**死锁**

### 如何解决死锁

- TCP 为每个连接设有一个持续定时器，**只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器**
- 如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小
  - 如果接收窗口不为0，那么发送方收到返回的ACK报文后，会重新开始发送数据，死锁的情况就会被打破
  - 如果仍然为0，那么收到ACK报文回复的发送方会重新启动持续计时器
- 窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 `RST` 报文来中断连接

## 糊涂窗口综合征

- 如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小
- 到最后，**如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**
- 糊涂窗口会造成资源的浪费
- 打个比方： 假设有一辆大巴可以载30人，但是每次来了1-2个人后，就直接发车，而不是等人多才一起发，那这样就很浪费资源
- 可以去仔细看看这个，[参考链接](https://www.xiaolincoding.com/network/3_tcp/tcp_feature.html#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87)

### 如何解决糊涂窗口

- 本质上，出现糊涂窗口的原因就是接收方可以通告给发送方一个较小的窗口，而且发送方又能发送小数据
- 所以，要从这两方面入手
- 接收方
  - 当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 `0`，也就阻止了发送方再发数据过来。
  - 等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来
- 发送方（ Nagle 算法，二者满足一个即可）
  - 要等到窗口大小 >= `MSS` 并且 数据大小 >= `MSS`
  - 收到之前发送数据的 `ack` 回包
- 在这之中，最重要的是，接收方要尽量实现不通告小窗口给发送方

# 拥塞控制

- 流量控制主要目的是避免发送方的数据填满接收方的整个缓存

- 与流量控制不同，拥塞控制主要的目的是避免发送方将数据填满整个**网络**
- 因为**在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大**
- 为了在「发送方」调节所要发送数据的量，定义了一个叫做「**拥塞窗口**」的概念
- **拥塞窗口（cwnd）是发送发维护的一个状态量**，会根据网络情况实时调节
- 所以，发送方的窗口应该是min（拥塞窗口，接收窗口）
- 拥塞窗口的变化规则是：
  - 只要网络中没出现阻塞，那么cwnd增大
  - 出现阻塞，则cwnd减小
- **只要发生了超时重传，就会认为网络出现了拥塞**
- 主要有4种控制算法 -> 慢启动，拥塞避免，拥塞发生，快速恢复

## 慢启动

- **当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1**
- 例子
  - 第一次只能发送1个，cwnd大小是1
  - 收到ACK应答后，cwnd变为2，可以发送两个
  - 收到两个ACK应答后，cwnd+2 -> 可以发送4个
  - ......
- 所以，这个过程是指数级增长的 -> 应该要有限制
- 有一个叫慢启动门限 `ssthresh` （slow start threshold）状态变量
  - cwnd < ssthresh -> 会采用慢启动算法
  - cwnd > ssthresh -> 采用拥塞避免算法

## 拥塞避免

- 当拥塞窗口 `cwnd` 「超过」慢启动门限 `ssthresh` 就会进入拥塞避免算法

- 一般来说 `ssthresh` 的大小是 `65535` 字节
- 规则是 -> **每当收到一个 ACK 时，cwnd 增加 1/cwnd**
- 例子
  - 假设目前的ssthresh=8，当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 `MSS` 大小的数据，变成了**线性增长**
- 拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些
- 如果这么增长，网络慢慢的会进入拥塞的状态，会出现丢包现象，当出现丢包，就会触发重传，会进入拥塞控制算法

## 拥塞发生

- 当网络出现拥塞时，会出现两种	重传机制，对应的拥塞控制算法也不一样

### 超时重传的拥塞控制

- ssthresh 设为 cwnd/2
- `cwnd` 重置为 cwnd的初始化值

- 接着就会重新开始慢启动
- 这种方式太激进了，反应也很强烈，会造成网络卡顿

### 快速重传的拥塞控制

- TCP认为快速重传这种情况网络拥塞并不严重，只丢了一小部分，所以不会像超时重传一样，直接回到初始值，而是还会保持一个较高的值，后续也会线性增长

- `cwnd = cwnd/2` ，也就是设置为原来的一半
- `ssthresh = cwnd`
- 接着会进入快速恢复算法

## 快速恢复

- 在快速恢复的过程中，首先 ssthresh = cwnd/2，然后 cwnd = ssthresh + 3，表示网络可能出现了阻塞，所以需要减小 cwnd 以避免，加 3 代表快速重传时已经确认接收到了 3 个重复的数据包
- 随后继续重传丢失的数据包，如果再收到重复的 ACK，那么 cwnd 增加 1。加 1 代表每个收到的重复的 ACK 包，都已经离开了网络。这个过程的目的是尽快将丢失的数据包发给目标
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，恢复过程结束
- ![小林coding的图片](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

# 其他

## RTT(Round-Trip Time 往返时延)

- 指的是**数据发送时刻到接收到确认的时刻的差值**，也就是包的往返时间

---

# 参考链接

- [小林coding](https://www.xiaolincoding.com/network/3_tcp/tcp_feature.html)

---



