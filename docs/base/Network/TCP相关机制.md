# 重传机制

## 超时重传

- 在发送数据时，设置一个定时器，在超过指定时间没有收到对方的ACK确认报文后，会重发这个数据

- 以下由两种情况会触发超时重传
  - 数据包丢失
  - 确认应答丢失

### 如何设置合理的超时重传时间（Retransmission Timeout -> RTO）

- 如果设置太大，重发就慢，效率差
- 如果设置太小，则会多发一次，浪费资源
- 所以，RTO应该比RTT略微大一点
  - 这里要考虑网络的波动情况
  - 所以会进行一些采样，加权等操作，最后得出一个平滑的RTO，同时，这个RTT也是会不断变化
- **每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送**

## 快速重传

- 对比超时重传，是以数据作为驱动，而不是时间
- 工作方式是当收到三个相同的 ACK 确认报文时，会在定时器过期之前，重传丢失的报文段
- 快速重传解决了超时重传的RTO设置问题，但是仍然存在一个问题 -> **重传的时候，是重传一个报文，还是重传所有报文的问题**
  - 例子： 假设发送发A发送了6个数据。分别是Seq1-Seq6，但是Seq2， Seq3丢失了
  - 那么这时，接收方B接收到Seq4， 5，6后，会连发三个ACK2到发送方A
  - 此时，发送方A并不知道，是要重传Seq2就好了，还是需要重传Seq2后的所有报文
  - 如果只传Seq2，那么效率很低，后面还需要再一次发送三个ACK3，来让发送发A重传Seq3
  - 而如果重传Seq2后的所有报文，虽然可以一次性重传丢失的Seq2，3，但是，Seq4-6已经成功接收过了，此时就会浪费资源
- 这个问题由SACK机制来解决

## SACK（Selective Acknowledgment，选择性确认）

- 这种方式是在TCP的头部字段中，加一个SACK的字段，这样就**可以将已收到的数据的信息发送给「发送方」**，发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**

## D-SACK(Duplicate SACK)

- **使用了 SACK 来告诉「发送方」有哪些数据被重复接收了**
- ...

# 滑动窗口

- TCP每发送一次数据，就需要一次应带，随后才能继续发送，这样的效率过低，而且有个明显的缺点： 数据包的**往返时间越长，通信的效率就越低**
- 为了解决上述问题，TCP引入了窗口的概念，这样的话，即使在往返时间较长的情况下，它也不会降低网络通信的效率
- 窗口的大小就是指**无需等待确认应答，而可以继续发送数据的最大值**

## 发送方的窗口

- 

## 接收方的窗口

# 其他

## RTT(Round-Trip Time 往返时延)

- 指的是**数据发送时刻到接收到确认的时刻的差值**，也就是包的往返时间

