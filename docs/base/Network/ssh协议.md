# SSH协议

## 什么是SSH协议

- ssh协议，全称Secure Shell（安全外壳协议），是*一种加密的网络传输协议，可用于**不安全**的网络环境中为网络服务提供安全的传输环境*
- *一般用于远程登录系统，同时SSH也支持[隧道协议](https://zh.m.wikipedia.org/wiki/隧道协议)、[端口映射](https://zh.m.wikipedia.org/wiki/端口映射)和[X11](https://zh.m.wikipedia.org/wiki/X_Window系統)连接。借助[SFTP](https://zh.m.wikipedia.org/wiki/SSH文件传输协议)或[SCP](https://zh.m.wikipedia.org/wiki/安全复制)协议，SSH还可以传输文件*
- 使用客户端-服务器模型

## 优点

- 对所有传输的数据加密
- 防止DNS欺骗和IP欺骗
- 传输的数据是经过压缩的，可以加快传输速度

## SSH主要组成

### 传输层协议

- 传输层协议提供服务器认证，数据机密性，信息完整性等的支持

### 用户认证协议

- 用户认证协议为服务器提供客户端的身份鉴别

### 连接协议

- 连接协议将加密的信息隧道复用成若干个逻辑通道，提供给更高层的应用协议使用。同时还有为许多高层的网络安全应用协议提供扩展的支持



## SSH安全验证

## 基于密码的安全验证

1. 客户端向服务器发起登录请求

2. 服务器收到请求后，将公钥发送给客户端

3. 如果客户端是第一次收到服务端的公钥，为了防止中间人假冒服务器，客户端主机会有以下提示

   - ```shell
     The authenticity of host 'xxx.xxx.com (xxx.xxx.xxx.xxx)' can't be established.
     RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.
     Are you sure you want to continue connecting (yes/no)? 
     ```

   - 意思是： 无法确定主机xxx.xxx.com的真实性，不过知道他的公钥指纹，是否继续连接？

   - 用的指纹代替key是因为key过长（RSA算法生成的公钥有1024位），所以对公钥hash生成一个128位指纹

4. 输入`yes`后，会将该公钥存在本地的**known_hosts**文件中，方便客户端后续连接该服务端比对存储在 **known_hosts** 文件里的公钥，从而确认是否为该服务端发来的公钥，如果存在则直接走密码登录

5. 随后输入密码，登录服务器，并且所有的数据都会通过ssh加密（使用服务器发来的公钥进行加密）

6. 服务器收到客户端的加密信息后，用自己的私钥进行解密比对，密码正确则连接成功

- 缺点： 可能会有中间者在冒充真正的服务器

- 解决方法： 客户端连接前，验证主机公钥 -> 只要服务器私钥不泄露，就可以避免中间人的攻击

## 基于密钥的安全验证

1. 客户端生成一对密钥，并把公钥放在服务器上
2. 客户端向服务器发起登录请求
3. 服务端收到请求后，会在本地匹配步骤一中存的客户端公钥，同时，生成随机数R，并用客户端的公钥对其加密，发送给客户端
4. 客户端收到加密信息后，用私钥解密得到R，然后对R和本次对话的SessionKey（会话密钥）用摘要算法生成摘要A，发送给服务器
5. 服务器收到A后，也会对R和SessionKe用同样的摘要算法生成摘要，生成摘要B，同时，比对A和B是否相同，相同则认为登录成功

### 法二

- 存在一个密钥认证中心，所有系统中提供服务的主机都将自己的公开密钥提交给认证中心，而任何作为客户机的主机则只要保存一份认证中心的公开 密钥就可以了。在这种模式下，客户机在访问服务器主机之前，还必须向密钥认证中心请求认证，认证之后才能够正确地连接到目的主机上

## SSH工作过程

### 版本号协商

- 目前SSH主要有两个版本（ssh1，ssh2），且互不兼容，双方需要协商确定使用的版本
-  版本号协商阶段报文都是采用明文方式传输的

### 密钥和算法协商

- SSH支持多种加密算法， 双方根据本端和对端支持的算法，协商出最终使用的算法
- 双方协商的原则是以客户端支持的协议为主，客户端支持的协议从左向右优先级依次递减，从优先级高的协议开始匹配，如果客户端支持的第一个协议，服务器也支持，则双方就使用这个协议，如果服务器不支持，则在匹配第二个客户端支持的协议，直到匹配到最后一个客户端支持的协议，如果服务器都不支持，则双方协商失败。
- 通过这一步，双方获得相同的会话密钥（对称）和会话ID
- 后续传输的数据，会利用该密钥进行加密和解密，保证数据安全
- 会话ID主要用于认证阶段
- ps： 在协商阶段之前，服务器端已经生成 RSA或 DSA密钥对，他们主要用于参与会话密钥的生成

### 认证阶段

- SSH客户端向服务器端发起认证请求， 服务器端对客户端进行认证
- 就是上面说的两种安全验证方式

### 会话请求阶段

- 认证通过后，客户端向服务器端发送会话请求

### 交互会话阶段

- 会话请求通过后，服务器端和客户端进行信息的交互

# 其他

## SessionKey：

- 一次性用于会话中加密用的对称式密钥，在此次连接结束该密钥即无效

## 签名验证：

- 用私钥进行签名，用公钥进行验证，从而保证信息来源是私钥拥有者。

### 主要流程

1. 发送方A将原文hash，得到信息摘要MD（这个过程一般采用不可逆的摘要算法 -> 这样即使中间人拿到这个摘要，也无法反推原文）
2. 发方A用自己的私钥A，用非对称算法（RSA等）对信息摘要MD进行加密，得到数字签名DS
3. 发方用对称密钥C（DES等算法...）对原文信息，数字签名DS，进行加密，得到加密信息E
4. 再用收方B的公钥B对对称密钥C进行加密，得到数字信封DE
5. 收方B拿到数字信封DE后，先用私钥B解密，得到对称密钥C
6. 用对称密钥C解密加密信息E，得到原文信息，数字签名
7. 然后用公钥A对数字签名DS解密，得到信息摘要MD
8. 收方B对原文信息采用同样的摘要算法进行hash，得到一个新的信息摘要MD2
9. 比对MD和MD2，如果一样，则是保密传输，签名是真实的，否则，则拒绝该签名

流程图....

- 另外一个问题 -> 怎么验证收方B拿到的公钥A一定是A的公钥，而不是中间人的
  - 用数字证书
- 主要保证数据的完整性和不可抵赖性
  - 不可抵赖： 如果公钥能解密，则内容一定是与该公钥对应的私钥加密而来，即可证明来源
  - 完整性： 数字签名的HASH值和自己计算出的HASH值一致，即可证明该内容是完整的未经修改过

## 加密解密：

- 需要同时使用公钥和私钥的加密算法是非对称加密，最常见的便是RSA




