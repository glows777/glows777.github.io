# 排序
## 分析排序算法
### 排序算法的执行效率
- 最好，最坏情况以及平均情况时间复杂度 **->** 因为数据不同，有的接近有序，有的完全无序
### 比较次数和交换次数
- 假设排序的n是一个规模很小的数据，如10，100等，那么即使同一阶时间复杂度的排序算法，性能也不一样
### 内存消耗&稳定性
- 内存消耗 **->** 在排序算法中，一般是指远低排序，就是空间复杂度为O(1)的排序算法
- 稳定性 **->** 指的是排序后，相等元素之间的先后顺序不变 **->** 举个栗子：2,9,3,4,8,3 排序后，里面的3，前面的3仍然在前面，后面的3仍然在后面
- 稳定排序算法在一些场景可能很有用 **->** 电商订单排序，有两个属性，订单时间和金额。先排时间，再稳定排序金额 **->** 这样，就可以得到按照金额从小到大排序，金额相同的下的那时间从早到晚的订单数据
- 稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，用稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。
## 冒泡排序
- 冒泡排序 **->** 每一次冒泡会对相邻的数据做比较，不满足大小关系，就互换位置。
- 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。排序过程如下：
- ![image](https://cdn.jsdelivr.net/gh/glows777/image-hosting@main/杂图/image.5dy00bce0zw0.webp) 
-  可优化 **->**  当某次冒泡操作已经没有数据交换，说明已经达到完全有序，不需要在执行后续的冒泡操作
- 实现代码如下：
```java

// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```
- 冒泡排序是原地排序，稳定的排序算法，时间复杂度是O(n2)
## 插入排序
- 将数据分为两个区间 **->** 已排序区间和未排序区间
- 初始的已排序区间只有一个元素，就是数组的第一个元素
- 插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。
- 例子： 排序4,5,6,1,3,2：
- ![image](https://cdn.jsdelivr.net/gh/glows777/image-hosting@main/杂图/image.4p82z0jkgmc0.webp) 
- 包括两种操作 **->** 元素的比较和移动 **->** 需要将数据a插入到已排序区间，需要拿a与已排序区间其他元素一次比较大小，找到合适位置，然后将插入点之后的元素往后移一位，腾出位置给元素a插入
- 代码实现：
```java

// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```
- 插入排序是原地排序，稳定的算法，时间复杂度是O(n2)
## 选择排序
- 类似于插入排序，分已排序和未排序区间，但选择排序每一次都会去未排序区间找最小的元素，放到已排序区间的末尾 **->** 效果：![image](https://cdn.jsdelivr.net/gh/glows777/image-hosting@main/杂图/image.jpn9jcrmz28.webp)
-  是原地排序算法，最好，最坏，平均时间复杂度都是O(n2)，不稳定 **->** 相比于插入和冒泡，这个比较少用
## 比较冒泡和插入排序
- 从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。
- 插入排序有很多调优的方法 **->** 希尔排序 **->** 很好的调优方法
## 小结
- 这三种，用的不多，只要求简单掌握