# 排序
## 归并排序
### 归并排序的原理
- 核心思想是 **->** 先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了
- 使用的是分治思想，通过递归来实现 **->** **分治是一种解决问题的处理思想，递归是一种编程技巧**
- 过程图：![image](https://cdn.jsdelivr.net/gh/glows777/image-hosting@main/杂图/image.42l3gfoun0o0.webp) ![image](https://raw.githubusercontent.com/glows777/image-hosting/main/杂图/image.42l3gfoun0o0.webp) 
### 归并排序的实现
- 归并通过递归来实现，递推公式 **->** `merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))` **->** 终止条件 **->** `p >= r 不用再继续分解`
- 其中,merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。
- 拆开排序后，需要将排好序的子数组合并 **->** `merge(merge(A[p...r], A[p...q], A[q+1...r]))`
- `merge`方法的过程是
	- 申请一个临时数组temp（大小与原数组相同），有指针i，j指向两个子数组的第一个元素
	- 比较，谁小，谁先放入temp，以及对应的指针往后移
	- 直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾
	- 最后再把临时数组 tmp 中的数据拷贝到原数组
	- ps **->** 可以利用哨兵优化 **->** 待完成
- 归并排序是稳定的排序算法，时间复杂度为O(nlogn),空间复杂度是O(n)
## 快速排序
### 快排原理
- 核心思想 **->** 如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）
- 遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的
- 用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了
- 实现过程：![image](https://cdn.jsdelivr.net/gh/glows777/image-hosting@main/杂图/image.5n5tntuty300.webp) 
### 实现快排
- 递推的公式 **->** `quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)`,终止条件是`p >= r`
- 这个过程需要一个分区函数partition()，用于随机选择一个元素作为pivot，然后对数组进行分区，函数返回 pivot 的下标
- partition()方法 **->** 数组要求原地分区操作
	- 通过指针 i 把数组分成两部分。p到i-1 的元素都是小于 pivot 的，暂且叫它“已处理区间”，i到r-1 是“未处理区间”。我们每次都从未处理的区间中取一个元素 `A[j]`，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 `A[i]`的位置 **->** 这样需要每次都搬移数组 **->** 借助数组插入操作的只需要交换这个技巧的思想优化：
	- 只需要小于时，将`A[i]`与 `A[j]`交换，就可以在 O(1) 时间复杂度内将 `A[j]`放到下标为 i 的位置，过程如图：![image](https://cdn.jsdelivr.net/gh/glows777/image-hosting@main/杂图/image.3ks6z6jr0ti0.webp) 
	- `i`用于记录已处理区间的下一位(每一次交换完 **->** 找到下一个小于pivot的值  ，就要更新已处理区间下一位的位置)，`j`用于遍历数组
	- 快排是一个不稳定的排序算法，原地排序算法，时间复杂度是O(nlogn)，最坏的情况会变成n2 **->** 例如：
	- 如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。
## 归并和快排的比较
- 相同点都是递归实现，递推公式相似
- 归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。
- 归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法，所以运用场景相当于快速排序，较小
## 其他
### 在O(n)的复杂度内，寻找无序数组的第K的元素
- 参考自快排的思想 **->** 分区
- 选择数组区间`A[0...n-1]`的最后一个元素 `A[n-1]`作为 pivot，对数组 `A[0...n-1]`原地分区，这样数组就分成了三部分，`A[0...p-1]`、`A[p]`、`A[p+1...n-1]`。
- 如果 p+1=K，那 `A[p]`就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 `A[p+1...n-1]`区间，再按照上面的思路递归地在 `A[p+1...n-1]`这个区间内查找。同理，如果 K<p+1，那我们就在 `A[0...p-1]`区间查找

