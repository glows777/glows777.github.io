# 线性排序 **->** 关键在于使用场景
## 桶排序
### 核心思想
- 核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了
- 流程：![image](https://cdn.jsdelivr.net/gh/glows777/image-hosting@main/drawing/image.2224jc2y2exs.webp)
- 时间复杂度为O(n)
	- 假设要排序的有n个数据，均匀分在m个桶中，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)
### 使用场景
#### 桶排序的使用场景
- 首先，数据要容易划分为m个桶，并且每一个桶要有天然的顺序，这样每一个桶排完序后，桶与桶之间不需要额外的排序
- 数据在各个桶之间要较为均匀，不能太多或者太少 **->** 假设都被分在一个桶，那复杂度就退化为O(nlogn)
#### 适用于外部排序
- **->** 数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中
- 例子 **->** 
	- 有 10GB 的订单数据，希望按订单金额（假设金额都是正整数）进行排序，但是内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办
	- 先扫描文件，查看订单金额的范围 **->** 假设最小1元，最大10万元
	- 那么，根据金额，划分为100个桶，第一个桶放1-1000，以此类推，第2个1001-2000......
	- 理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了
	- 但是，如果金额不是均匀分布，那么，就算划分之后，文件也是过大，还是无法放入一个文件 **->** 针对大文件我们再划分，例如 **->** 1-1000的区间，再划分为10个小区间，还是不行，再划分，直至可以读入内存
## 计数排序
### 核心思想
- 是桶排序的一种特殊情况 **->** 当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间
- 流程 **->** 举个栗子来说明一下情况 **->** 有数据（2，5，3，0，2，3，0，3）需要排序
	- 范围是0-5，所以用大小为6的数组`C[6]`表示桶下标对应分数，存储的不是考生，而是对应该分数考生的数量
	- 那么，只需要遍历一遍数据，即可获得`C[6]`的值
	- 不难看出，大小为3的数据有3个，小于3的有4个，所以，大小为3的数据在排序之后，在有序数组中，会存储在下标为4,5,6的位置
- 问题来了 **->** 如何及计算每个数据在排序后对应的存储位置
	- 对`C[6]`数组顺序求和，`C[6]`存储的数据就变成了下面这样子。`C[k]`里存储小于等于 k 的数据个数 ![image](https://cdn.jsdelivr.net/gh/glows777/image-hosting@main/drawing/image.60xsc53dmws0.webp) 
	- 从后到前依次扫描数组 A。比如，当扫描到 3 时，从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，小于等于 3 的数据有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的`C[3]`要减 1，变成 6
	- 以此类推，当扫描到第 2 个大小为 3 的数据的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了
	- 整个过程如下：![image](https://cdn.jsdelivr.net/gh/glows777/image-hosting@main/drawing/image.sqdp737hbu8.webp) 
	- 计数排序之所以被叫做计数排序，是因为借助了一个“计数”的数组来进行排序
### 使用场景
- 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数
- 例子 **->** 有负数的话，可以整体加上一个数，使其变为正数，然后在排序；或者有小数点，可以整体扩大十倍，变为整数在排序
## 基数排序
### 例子
- 有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序
- 用快排的话，时间复杂度为O(nlogn)，桶排序或者计数排序，手机号码有11位，太大了 **->** 解决方法
- 手机号码有11位，如果前面几位a比b大，那么不用继续比较
-  **->** 先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了 **->** 类似流程：![image](https://cdn.jsdelivr.net/gh/glows777/image-hosting@main/drawing/image.2zqm0v5x0sa0.webp) 
- 这里用于排序每一位的排序算法要稳定，如果不稳定，那么最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系 **->** 低位排序就没有意义
### 时间复杂度
- 根据每一位来排序，可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)
### 变体
- 如果要排序的数据不是等长的，那么可以补到等长，例如 **->** 位数不够后面补0（在排序单词中 **->** ASCII码中，所有字母都是大于‘0’的）
### 使用场景
- 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了
## 拓展
- 如何根据年龄给 100 万用户排序？
-  **->** 假设年龄的范围最小 1 岁，最大不超过 120 岁。遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。

