> 学习自[链接](https://time.geekbang.org/column/article/41440)
# 递归 
## 理解递归
### 关于递归
- 应用广泛，许多数据结构和算法都需要用到 **->** 例如
- DFS深度优先搜索
- 前中后序二叉树遍历等
### 递归需要满足三个条件
- 一个问题的解可以分解为几个子问题的解 **->** 数据规模更小的问题
- 这个问题与分解之后的子问题，除了数据规模不同之外，求解思路完全 一样
- 存在递归终止条件 **->** 把问题拆为子问题，子问题再拆为子子问题，一层一层拆下去，不能存在无限循环，必须要有终止条件
### 怎么写递归？
- **->** 关键是**写出递推公式，以及终止条件**
- 一个例子：
	- 爬楼梯，一次可以爬1或2格，求爬到第n格有多少种爬法
	- 不难理解，第n格，可以理解为由**爬(n-1)格的所有情况再爬1格**以及**爬(n-2)格的所有情况再爬2格**两种情况组成，也就是说用公式表达就是： `fn(n) = fn(n - 1) + fn(n - 2)`
	- 然后在来确定终止条件 **->** 当n=1时，fn(1) = 1;当n=2时，fn(2) = 2 （因为，n=2，只有两种可能，爬1格或者2格，而`fn(2) = fn(1) + fn(0)`明显不符合事实,所以n=2也是终止条件）
	- 所以，代码如下：
```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```
- 小总结 **->** 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。
- 弄清楚如何“递”（往深处递，“查数据”），如何“归”（向上归数据） **->** 但不要纠结递和归的过程
- 只要遇到递归，可以把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤，不需要太理解里面的细节，因为这个过程有一点难理解
## 递归代码需要警惕的点
### 注意堆栈溢出
- 为什么会出现堆栈溢出？ **->** 函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。
- 如何避免？**->** 可以在代码中限制递归的最大深度来解决这个问题 **->** 一个例子
```java

// 全局变量，表示递归的深度。
int depth = 0;

int f(int n) {
  ++depth；
  if (depth > 1000) throw exception;
  
  if (n == 1) return 1;
  return f(n-1) + 1;
}
```
- 缺点：因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。
### 减少重复计算
- 递归过程可能会出现重复计算的问题，还是爬楼梯问题，要计算f(5)，就需要计算f(4)和f(3)，计算f(4)需要计算f(3)和f(2)，在此过程中，f(3)被计算多次
- 可以通过一个数据结构（如散列表）来保存求解过的f(n)，当需要递归调用时，先检查是否已经求解过了，有，则直接从散列表中返回，不需要重复计算，改善的代码如下：
```java

public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList可以理解成一个Map，key是n，value是f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSolvedList.get(n);
  }
  
  int ret = f(n-1) + f(n-2);
  hasSolvedList.put(n, ret);
  return ret;
}
```
### 时间和空间效率问题
- 递归涉及许多函数调用，如果调用的数量较大，会较耗时
- 在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销
## 将递归改为非递归
- 还是爬楼梯的例子，改变后的代码：
```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  int ret = 0;
  int pre = 2;
  int prepre = 1;
  for (int i = 3; i <= n; ++i) {
    ret = pre + prepre;
    prepre = pre;
    pre = ret;
  }
  return ret;
}
```
- 理论上，所有的递归代码都可以改为迭代循环的非递归写法 **->** 因为，递归本身实际上是借助栈来实现的，用的是系统或者虚拟机提供的而已，我们也可以自己模拟入栈出栈的过程，将递归改为非递归，但是，本质上，还是递归，还增加了实现的复杂度 **->** 所以要根据实际情况判断是否合适
## 其他
- 在调试递归代码时，单步调试不太合适 **->** 可以使用：
- 打印日志，发现每一次的递归值 **->** 简单的实现就是打印出来每一次递归的值
- **结合条件断点调试** 